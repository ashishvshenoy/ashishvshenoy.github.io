<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Recommender Systems and Collaborative Filtering - Walkthrough | Ashish Shenoy</title> <meta name="author" content="Ashish Shenoy"> <meta name="description" content="Recommender Systems and Collaborative Filtering - Walkthrough"> <meta name="keywords" content="collaborative filtering, svd, matrix factorization, gradient descent, movie recommender, recommender systems, content filtering"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700%7CRoboto+Slab:100,300,400,500,700%7CMaterial+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://ashishvs.in/blog/2017/recommender-systems-and-collaborative-filtering-walkthrough/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Ashish </span>Shenoy</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Recommender Systems and Collaborative Filtering - Walkthrough</h1> <p class="post-meta">March 21, 2017</p> <p class="post-tags"> <a href="/blog/2017"> <i class="fas fa-calendar fa-sm"></i> 2017 </a> </p> </header> <article class="post-content"> <p>This is a walkthrough of Collaborative Filteirng that I wrote for a class.</p> <h1 id="summary">Summary</h1> <p>Every user on the internet today is faced with an overwhelming set of choices on almost every website he/she visits. Be it Facebook, Spotify, Amazon or Google, there is a need to filter, rank and deliver relevant information quickly in order to alleviate the problem of information overload. Recommender systems are used in almost every major website these days to solve this problem by searching through a large volume of dynamically generated information to provide users with personalized content and services. See Figure 1 <a href="(https://www.ischool.utexas.edu/~i385q/readings/Balabanovic_Shoham-1997-Fab.pdf)">1</a>.</p> <p><img src="/assets/img/RecommenderSystem.png" alt="RecommenderSystem.png"></p> <p>After completing this walkthrough you should be able to :</p> <ul> <li> <p>Understand what Recommender Systems do.</p> </li> <li> <p>Get a high level overview of different approaches used in Recommender Systems.</p> </li> <li> <p>Understand the concept of collaborative filtering.</p> </li> <li> <p>Learn how to implement collaborative filtering using low dimensional matrix factorization method.</p> </li> <li> <p>Get a hands on experience on building a collaborative filtering recommender system for a real-life dataset.</p> </li> </ul> <h1 id="sec:examples">Background</h1> <p>Recommender systems have become extremely popular in recent years. They are a subclass of information filtering systems that seek to predict the “rating” or “preference” that a user would give to an item. Applications of recommender systems include: movies, music, news, books, research articles, search queries, social tags, and products. For example, recommending news articles to on-line newspaper readers.<br> <strong>Basic Concepts :</strong><br> <strong>User:</strong> any individual who provides ratings to a system. User who provides provides ratings ratings and user who receive receive recommendations recommendations.<br> <strong>Item:</strong> anything for which a human can provide a rating. Eg. art, books, CDs, journal articles, music, movie, or vacation destinations<br> <strong>Ratings:</strong> vote from a user for an item by means of some value. Scalar/ordinal ratings (5 points Likert scale), binary ratings like/dislike), unary rating (observed/abase of rating). Recommender systems typically produce a list of recommendations in one of two ways – through collaborative and content-based filtering.</p> <ul> <li> <p><strong>Collaborative filtering</strong>: This approach is used to build a model from user’s past behaviour i.e. items previously purchased or selected and/or numerical ratings given to those items as well as similar decisions made by other users. This model is then used to predict items (or ratings for items) that the user may have an interest in.</p> </li> <li> <p><strong>Content-based filtering</strong>: This approach uses features of an item in order to recommend additional items with similar features/properties.<br> Sometimes the above two approaches are often combined and termed as Hybrid Recommender Systems.</p> </li> </ul> <p><img src="/assets/img/coll_filter.jpg" alt="coll_filter.jpg"></p> <p><img src="/assets/img/content_based.jpg" alt="content_based.jpg"></p> <p><img src="/assets/img/spotify_recommendation.png" alt="spotify_recommendation.png"></p> <p><img src="/assets/img/amazon_collab.png" alt="amazon_collab.png"></p> <p>The differences between collaborative and content-based filtering can be demonstrated by comparing two popular music recommender systems – Last.fm and Pandora Radio.<br> Last.fm creates a “station” of recommended songs by observing what bands and individual tracks the user has listened to on a regular basis and comparing those against the listening behavior of other users. Last.fm will play tracks that do not appear in the user’s library, but are often played by other users with similar interests. As this approach leverages the behavior of users, it is an example of a collaborative filtering technique.<br> Pandora uses the properties of a song or artist (a subset of the 400 attributes provided by the Music Genome Project) in order to seed a “station” that plays music with similar properties. User feedback is used to refine the station’s results, deemphasizing certain attributes when a user “dislikes” a particular song and emphasizing other attributes when a user “likes” a song. This is an example of a content-based approach.<br> Each type of system has its own strengths and weaknesses. In the above example, Last.fm requires a large amount of information on a user in order to make accurate recommendations. This is an example of the cold start problem, and is common in collaborative filtering systems. While Pandora needs very little information to get started, it is far more limited in scope (for example, it can only make recommendations that are similar to the original seed).</p> <p>Recommender systems are a useful alternative to search algorithms since they help users discover items they might not have found by themselves. Interestingly enough, recommender systems are often implemented using search engines indexing non-traditional data.</p> <p>In this tutorial we will be exploring an implementation of Collaborative Filtering using matrix factorization.</p> <h2 id="the-problem">The Problem</h2> <p>To illustrate an everyday application of Collaborative Filtering, let’s consider building the “Recommended Movies” section of IMDB. Most of the recommender systems usually have a set of users and a group of items, such as videos, movies, books or music. A common insight that these recommenders follow are that personal tastes are correlated. If Alice and Bob both like X and Alice likes Y then Bob is more likely to like Y especially (perhaps) if Bob knows Alice. Thus, given that the users have rated some items in the system, we would like to predict how the users would rate the items that they have not yet rated, so that we can make recommendations to the users.<br> Assume each user gives a movie a rating between 1 and 5 stars and we have 5 users and 7 movies. We can represent this users and video ratings information as a matrix such as the one in figure .<br> Our task now is to predict the ratings for all the entries with ?. We will use low dimensional matrix factorization method to accomplish this.</p> <p><img src="/assets/img/matrix1.png" alt="matrix1.png"></p> <h2 id="low-dimensional-matrix-factorization">Low Dimensional Matrix Factorization</h2> <p>To get the intution behind matrix factorization, lets consider the example in figure. As discussed above personal tastes are correlated. For example, two users would give high ratings to a certain movie like the actors/singers of the video or if the genre is liked by both the users. Hence, if we can find these characteristics/features/properties of users and movies, we can easily predict the rating of unknown movies. Also the number of features are very small as compared to number of users and movies. Now lets see the math behind matrix factorization. We need to obtain the two matrices: users(P) and movies(Q)<br> We have a \(m \times n\) matrix of users and items and we need to find two matrices P(\(m \times k\)) and Q(\(n \times k\)) such that their product approximates R. See Figure below. Note: \(k \ll m,n\) \(R \approx P \times Q^T = \widehat{R}\)</p> <p><img src="/assets/img/MatrixFactorization.png" alt="MatrixFactorization.png"></p> <p><strong>Why not SVD?</strong><br> You must be wondering why we are not using SVD for factorization. The problem is that SVD is not defined if there are missing values in matrix. We can tackle this problem by filling missing values with zeros or the average rating that user has given to rest of the videos. But if the matrix is too big, millions of users and items then this may not be a good idea.</p> <h2 id="cold-start">Cold Start</h2> <p>A common problem faced by most recommender systems is something called as a Cold start problem.<br> In collaborative filtering, the recommender system tries to infer the rating an active user would give to an item from the choices like-minded users would have made. This approach would fail when there are some items which no user has rated previously. Specifically, it concerns the issue that the system cannot draw any inferences for users or items about which it has not yet gathered sufficient information.</p> <h2 id="gradient-descent">Gradient Descent</h2> <p><img src="/assets/img/gradient_descen.png" alt="gradient_descen.png"></p> <p>How do we now find the matrices P and Q? The idea behind finding the values for these two matrices is that their products should nearly be the same as the one in figure above along with the predicted values for the missing values.<br> To do this, we can start off by initializing P and Q with random values and use gradient descent to find the local minima of the difference between the actual matrix and the calculated matrix iteratively.<br> We can write the error between the estimated rating and actual rating for every user-video pair as given below. Our task here is to minimize the error in each individual rating.<br> Note: Objective function is multiplied by a factor of 1/2 in order to remove 2 during differentiation.<br> \(e_{ij}^2 = \frac{1}{2}(r_{ij} - \hat{r}_{ij})^2 = \frac{1}{2}(r_{ij} - \sum_{k=1}^K{p_{ik}q_{kj}^T})^2\\\)</p> <p>Now we need to know the direction in which we should modify the values of \(p_ik\) and \(q_kj\). This can be obtained by calculating the gradient at the current value. This is done by differentiating the above equation with respect to \(p_{ik}\) and \(q_{kj}\) separately : <br> \(\frac{\partial}{\partial p_{ik}}e_{ij}^2 = -(r_{ij} - \hat{r}_{ij})(q_{kj})\) \(\frac{\partial}{\partial q_{ik}}e_{ij}^2 = -(r_{ij} - \hat{r}_{ij})(p_{ik})\)</p> <p>Now we can write the update rule for \(p_{ik}\) and \(q_{kj}\) as follows :<br> \(p_{ik}^{t+1} = p_{ik}^t - \alpha \frac{\partial}{\partial p_{ik}^t}e_{ij}^2 = p_{ik}^t - \alpha (-r_{ij} + \hat{r}_{ij})q_{kj}^t\) \(q_{kj}^{t+1} = q_{kj}^t - \alpha \frac{\partial}{\partial q_{kj}^t}e_{ij}^2 = q_{kj}^t - \alpha (-r_{ij} + \hat{r}_{ij})p_{ik}^t\)</p> <h2 id="weighted-objective-function">Weighted Objective Function</h2> <p>In order to penalize only the known rating we will be using weighted objected function where \(w_{ij} = 1\) if \(r_{ij}\) is observed and \(w_{ij} = 0\) otherwise. \(\min_{P,Q} \frac{1}{2}\times w_{ij}(r_{ij} - \sum_{k=1}^K{p_{ik}q_{kj}^T})^2\)</p> <h2 id="regularization">Regularization</h2> <p>The above algorithm can lead to overfitting. To avoid this, we use L2 regularization to minimize the norm of the residual as follows :<br> \(e_{ij}^2 = \frac{1}{2}\times w_{ij}(r_{ij} - \sum_{k=1}^K{p_{ik}q_{kj}^T})^2 + \lambda {(||P||^2 + ||Q||^2)}\)<br> \(\lambda\) provides a knob on the magnitudes of the user-feature and video-feature vectors. It ensures that P and Q would give a good approximation of R without having to contain large numbers. Thus our objective function now becomes:<br> \(\min_{P,Q} \frac{1}{2}||W\cdot(R-PQ^T)||^2 + \lambda(||P||^2 + ||Q||^2)\)<br> Here W is the indicator matrix i.e. \(w_{ij} = 1\) if \(r_{ij}\) is observed and \(w_{ij} = 0\) otherwise.<br> The new update rules after calculating the gradient are as follows:<br> \(\Delta P = W\cdot(PQ^T - R)Q +2\lambda P\)<br> \(\Delta Q = (W\cdot(PQ^T - R))^TP +2\lambda Q\)<br> \(P^{t+1} = P^t - \alpha \Delta P^t = P^t - \alpha(W\cdot(P^tQ^{T,t} - R)Q^t +\lambda P^t)\) \(Q^{t+1} = Q^t - \alpha \Delta Q^t = Q^t - \alpha((W\cdot(P^tQ^{T,t} - R))^TP^t +\lambda Q^t)\)<br> Note: Multiplication factor 2 can be consumed in \(\lambda\).</p> <h2 id="biases">Biases</h2> <p>The variation in rating values is most of the times associated with either the item being rated or the user who is rating. Certain users consistently give higher ratings to items while sometimes the item always commands a higher rating from all the users. We use a first order approximation of the above bias as follows : \({b_i}_j = \mu + b_i + b_j\) Where \(\mu\) is the overall average rating for the item.</p> <h1 id="lab">Lab</h1> <p>Now let’s perform a more thorough analysis of collaborative filtering using matrix factorization method. To do this we will use the dataset available here : <a href="http://grouplens.org/datasets/movielens/100k/" rel="external nofollow noopener" target="_blank">http://grouplens.org/datasets/movielens/100k/</a><br> The goal of this exercise is to build a recommendation system for IMDB. More specifically :</p> <ul> <li> <p>Construct the User-Item Matrix.</p> </li> <li> <p>Define a factorization model - cost function. We will use matrix factorization, regularization and gradient descent to obtain a model that minimizes the below function. \(\min_{M,U} \frac{1}{2}||R\cdot(Y - MU^T)||_F^2 + \lambda(||M||_F^2 + ||U||_F^2)\) Here M is the movie matrix, U is the user matrix, R is the indicator weight matrix \(||\cdot||_F\) is Frobenius norm, the operator \(\cdot\) means the dot product and $\lambda$ is the regularization parameter.</p> </li> <li> <p>Understand the impact of increasing or decreasing the number of features on the accuracy of the model.</p> </li> <li> <p>Experiment the convergence of the model by varying the learning rate and the regularization parameters.</p> </li> <li> <p>Understand the impact of adding bias.</p> </li> </ul> <h2 id="load-the-dataset">Load the dataset</h2> <p>Download the dataset from this link <a href="http://pages.cs.wisc.edu/~ashenoy/CS532/" rel="external nofollow noopener" target="_blank">http://pages.cs.wisc.edu/~ashenoy/CS532/</a> Since the above dataset has many files and asks you to merge the files using specific commands we have merged the data for you and have created training and testing datasets. The dataset in total has 100K ratings. We will be using 80K for training and 20K for testing. <strong><code class="language-plaintext highlighter-rouge">train_all.mat</code></strong> has two matrices each of size \(1682 \times 943\) matrix. In <strong><code class="language-plaintext highlighter-rouge">Rating_train</code></strong>(Y) each entry (i,j) is the rating given to the ith movie by jth user and <strong><code class="language-plaintext highlighter-rouge">L_train</code></strong>(R) is the corresponding indicator matrix. Similarly <strong><code class="language-plaintext highlighter-rouge">test_all.mat</code></strong> has two matrices each of size $1682 \times 943$ matrix. <strong><code class="language-plaintext highlighter-rouge">test_Y</code></strong> represents the corresponding test rating matrix and <strong><code class="language-plaintext highlighter-rouge">test_R</code></strong> as the corresponding test indicator matrix.<br> Write the MATLAB code to load <strong><code class="language-plaintext highlighter-rouge">train_all.mat</code></strong> and <strong><code class="language-plaintext highlighter-rouge">test_all.mat</code></strong> and verify the above.</p> <h2 id="initialize-learning-rate-regularization-parameter-and-maximum-number-of-iterations">Initialize learning rate, regularization parameter and maximum number of iterations</h2> <p>Now that the dataset is loaded and we have the training and testing set, we can now initialize the following tuning parameters :<br> \(alpha = 0.001 lambda = 10 max\_iter = 500\)</p> <h2 id="initialize-the-mmovies-and-uusers-matrix">Initialize the M(movies) and U(users) matrix</h2> <p>M and U matrices are the factors of the ratings matrix Y. Let’s start with a feature size of 10 and initialize these two matrices with appropriate dimensions and fill them with normally distributed random values.</p> <h2 id="gradient-descent-1">Gradient Descent</h2> <p>Now that you have the M(movies) and U(users) matrices, write code to update M and U using gradient descent method :<br> \(M^{t+1} = M^t - \alpha(R\cdot(M^tU^{t,T}-Y)U^t +\lambda M^t)\)<br> \(U^{t+1} = U^t - \alpha((R\cdot(M^tU^{t,T})-Y)^TM^t +\lambda U^t)\)<br> This has to be performed \(max\_iter\) number of times.</p> <h2 id="formulate-the-loss-function">Formulate the loss function</h2> <p>Everytime after updating M and U, write code to check for the convergence. We can assume convergence if the calculated error using the formula below is less than a threshold 0.0001. If the convergence condition is met we should stop the gradient calculation.<br> \(\frac{||M^{t+1}-M^t||^2_F+||U^{t+1}-U^t||^2_F }{||M^t||^2_F+||U^t||^2_F} &lt; \epsilon\)</p> <h2 id="predicted-ratings">Predicted Ratings</h2> <p>After performing all of the above steps, you will end up with an updated M and U matrix. Lets call them \(M\_result\) and \(U\_result\) and assign them to these two new variables. Now we can obtain the predicted ratings matrix by calculating the dot product of \(M\_result\) and \(U\_result\).</p> <h2 id="calculate-error">Calculate Error</h2> <p>Now that you have the predicted ratings matrix, let’s calculate the error rate using the test dataset.<br> \(error\_rate = \frac{||test\_R \cdot (predicted\_matrix - test\_Y)||^2_F}{||test\_Y||^2_F}\)</p> <h2 id="varying-number-of-features">Varying number of features</h2> <p>Now let’s try and analyze how varying the number of features in M and U matrices impacts the accuracy. Plot a graph between \(error\_rate\) on Y axis and \(num\_of\_features\) on X axis. What do you observe? what is the best value of number of features? Take atleast 10 values ranging from min to max number of features.</p> <h2 id="varying-regularization-parameter">Varying regularization parameter</h2> <p>Now let’s analyze how varying \(\lambda\) impacts the accuracy. Plot a graph between \(error\_rate\) on Y axis and \(\lambda\) on X axis. What do you observe? what is the best value of lambda? Take logarithmic values of lambda( i.e 0.01, 0.1 etc). Take at least 10 values.</p> <h2 id="varying-learning-rate">Varying learning rate</h2> <p>Also analyze how varying \(\alpha\) impacts the convergence rate. What happens if you make alpha too small( like 0.0001 or 0.00001), keeping number of iterations as same? Also what if you make alpha too big(like 1, 10)?</p> <h2 id="predict-missing-ratings-with-best-values-of-parameters">Predict missing ratings with best values of parameters</h2> <p>Now that you have tuned all the parameters and have got the best values of each of them, lets find out the missing ratings in Y. Output the result(user, movie, rating) in a text file. Note: use the indicator matrix to find out missing entries and round them before writing in text file.</p> <p>If you found this work useful please cite as:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@misc{AshishShenoy_Rec_Sys,
  author        = {Shenoy, Ashish},
  title         = {Recommender Systems and Collaborative Filtering - Walkthrough},
  howpublished  = {\url{https://www.ashishvs.in}},
  year          = {2017},
  note          = {Accessed: 2017-03-21},
  url           = {www.ashishvs.in}
} 
</code></pre></div></div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Ashish Shenoy. Last updated: December 20, 2023. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-65691687-3"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-65691687-3");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>